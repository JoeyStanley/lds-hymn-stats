---
title: "Analysis Functions"
author: "Joey Stanley"
date: "2023-10-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

This script is intended to be loaded by other scripts. It load the data and any functions that might be needed. 


## Prep and load data

```{r}
library(tidyverse)
library(readxl)
library(lubridate)
library(ggthemes)
library(DescTools)

# Part of tidymodels
library(infer) # for chisq_test()
```


When running this script in situ, the path is in _scripts. But when calling, it's relative to the blog post, so I need to back up one more folder.

```{r}
if (str_extract(getwd(), "\\w+\\Z") == "_scripts") {
    path_to_data <- "../data/"
} else {
    path_to_data <- "../../data/"
}
```


### The Frequency Data

Actually read in the data. All the prepping, auditing, and querying is done in reshaperaw_freq_data.Rmd.

```{r}
freqs <- read_csv(paste0(path_to_data, "freqs.csv"), show_col_types = FALSE) %>%
    mutate(date = as.Date(date),
           type = factor(type, levels = c("Opening", "Sacrament", "Intermediate", "Closing")))
```

### The Notes Data

```{r}
notes <- read_csv(paste0(path_to_data, "cleaned_notes_data.csv"), show_col_types = FALSE) %>%
    
    # Get the factor levels right
    mutate(voice = factor(voice, levels = c("soprano", "alto", "tenor", "bass")),
           key_signature = factor(key_signature, levels = c("A", "D", "G", "C", "F", 
                                                            "Bb", "Eb", "Ab", "Db"))) %>%
    
    arrange(midi) %>%
    mutate(note_label = fct_inorder(note_label)) %>%
    arrange(hymn_num, voice, id)
```

### Helper datasets

Also load this lookup table.

```{r}
name_num_lookup <- read_csv(paste0(path_to_data, "name_num_lookup.csv"), show_col_types = FALSE) 
```

```{r}
note_name_midi_lookup <- notes %>%
    mutate(note_label = paste0(note, octave)) %>%
    filter(!is.na(midi)) %>%
    distinct(note_label, midi) %>%
    arrange(midi) %>%
    mutate(note_label = fct_inorder(note_label))
```


## Export functions

```{r}
# export_for_latex <- function(name, ...) {
#     path <- paste0("../documents/latex/images/", name, ".pdf")
#     ggsave(filename = path, device = cairo_pdf, ...)
#     
#     path_website <- paste0("/Users/joeystan/GitHub/lds-hymn-stats/images/", name, ".jpeg")
#     ggsave(filename = path_website, ...)
# }
```

```{r}
# export_table_for_website <- function(df, .name) {
#     path <- paste0("/Users/joeystan/GitHub/lds-hymn-stats/tables/", .name, ".html")
#     df %>%
#         mutate(across(is.double, ~round(., digits = 2))) %>%
#         select(-label, -n) %>%
#         select(`Hymn` = hymn_name, 
#                `Num` = hymn_num, 
#                `Avg. per year` = avg_per_year,
#                `every x weeks` = every_x_weeks,
#                `every x months` = every_x_months,
#                `every x years` = every_x_years) %>%
#         # kableExtra::kable() %>%
#         # kableExtra::kable_styling("striped") %>%
#         # kableExtra::save_kable(path, self_contained = FALSE)
#         gt::gt() %>%
#         gt::gtsave(path)
# }

# freqs %>%
#     filter(hymn_num %in% 169:196) %>%
#     cleveland_plot(return = "table") %>%
#     export_table_for_website("sacrament_hymns")
```

## Cleveland plot

First, calculate the number of weeks I have data for given the input dataset

```{r}
get_n_distinct_meetings <- function(df = freqs) {
    df %>%
        select(date, ward) %>%
        distinct() %>%
        nrow()
}
```

```{r}
cleveland_plot <- function(df, 
                           return = "plot", export = FALSE,
                           title = "Average number of times hymns are sung per year per ward", 
                           subtitle = "", 
                           unique_meetings = get_n_distinct_meetings(), 
                           filter_n = 0, 
                           max_n = 1E5,
                           x_buffer = 1,
                           breaks = 0.5,
                           base_size = 12,
                           extra_cols, 
                           inverse_x = FALSE,
                           ...) {
    
    # Get number of times each hymn was sing per year
    this_avg_per_year_lookup <- df %>%
        filter(hymn_num != 0) %>%
        count(hymn_num) %>%
        mutate(avg_per_year = n / unique_meetings * 48,
               every_x_weeks = 48 / avg_per_year,
               every_x_months = every_x_weeks / 48 * 12,
               every_x_years  = 1 / avg_per_year) %>%
        arrange(-avg_per_year) %>%
        select(-n)

    this_freq_info <- df %>%
        count(hymn_num, sort = TRUE) %>%
        filter(n >= filter_n,
               n <= max_n) %>%
        left_join(name_num_lookup, by = "hymn_num") %>%
        left_join(this_avg_per_year_lookup, by = "hymn_num") %>%
        mutate(hymn_num = factor(hymn_num),
               hymn_num = fct_inorder(hymn_num),
               hymn_num = fct_rev(hymn_num),
               label = paste0(hymn_name, " (", hymn_num, ")"))
    
    # If I need to retain any rows for some plot aesthetic, this is how those are kept.
    if (!missing(extra_cols)) { 
        extra_cols_to_join <- df %>%
            select(hymn_num, {{extra_cols}}) %>%
            mutate(hymn_num = factor(hymn_num)) %>%
            distinct()
        
        this_freq_info <- this_freq_info %>%
            left_join(extra_cols_to_join, by = "hymn_num")
    }

    max_x <- max(this_freq_info$avg_per_year) + x_buffer
    this_nudge_x <- max(this_freq_info$avg_per_year) / 60 # 3.5 turns to 0.05

    # The lines for the plot
    this_lines <- this_freq_info %>%
        mutate(line_start = 0) %>%
        pivot_longer(cols = c(line_start, avg_per_year), names_to = "line_position", values_to = "value")


    p <- ggplot(this_freq_info, aes(avg_per_year, hymn_num, ...)) +
        geom_point() +
        geom_text(aes(label = label), nudge_x = this_nudge_x, 
                  hjust = 0, family = "Avenir", size = 3, show.legend = FALSE) +
        geom_line(data = this_lines, aes(x = value, group = hymn_num)) +
        scale_x_continuous(limits = c(0, max_x), breaks = seq(0, 5, breaks),
                           expand = expansion(add = c(0, 0), mult = c(0,0))) +
        labs(x = "number of times sung per year per ward, on average",
             y = NULL,
             title = title,
             subtitle = subtitle) +
        theme_minimal(base_size = base_size, base_family = "Avenir") + 
        theme(axis.ticks.y = element_blank(),
              axis.text.y = element_blank(),
              axis.line.y = element_line(color = "gray80"),
              panel.grid.major.y = element_blank(),
              panel.grid.minor.y = element_blank())
    
    if (export) {
        export_for_latex(..., plot = p)
    }

    if (return == "plot") {
        return(p)
    }
    if (return == "table") {
        return(this_freq_info)
    }
    if (return == "both") {
        return(list(this_freq_info, p))
    }
}
```

### Attempts at years version

```{r, eval = FALSE}
# cleveland_plot_years <- function(df, 
#                                  return = "plot", export = FALSE,
#                                  title = "", subtitle = "", 
#                                  unique_meetings = get_n_distinct_meetings(), 
#                                  filter_n = 0, 
#                                  max_n = 1E5,
#                                  x_buffer = 1,
#                                  breaks = 0.5,
#                                  base_size = 12,
#                                  extra_cols, 
#                                  ...) {
#     
#     # Get number of times each hymn was sing per year
#     this_avg_per_year_lookup <- df %>%
#         filter(hymn_num != 0) %>%
#         count(hymn_num) %>%
#         mutate(avg_per_year = n / unique_meetings * 48,
#                every_x_weeks = 48 / avg_per_year,
#                every_x_months = every_x_weeks / 48 * 12,
#                every_x_years  = 1 / avg_per_year) %>%
#         arrange(-avg_per_year) %>%
#         select(-n)
#     
#     this_freq_info <- df %>%
#         count(hymn_num, sort = TRUE) %>%
#         filter(n >= filter_n,
#                n <= max_n) %>%
#         left_join(name_num_lookup, by = "hymn_num") %>%
#         left_join(this_avg_per_year_lookup, by = "hymn_num") %>%
#         mutate(hymn_num = factor(hymn_num),
#                hymn_num = fct_inorder(hymn_num),
#                hymn_num = fct_rev(hymn_num),
#                label = paste0(hymn_name, " (", hymn_num, ")"))
#     
#     # If I need to retain any rows for some plot aesthetic, this is how those are kept.
#     if (!missing(extra_cols)) {
#         extra_cols_to_join <- df %>%
#             select(hymn_num, {{extra_cols}}) %>%
#             mutate(hymn_num = factor(hymn_num)) %>%
#             distinct()
# 
#         this_freq_info <- this_freq_info %>%
#             left_join(extra_cols_to_join, by = "hymn_num")
#     }
# 
#     max_x <- max(this_freq_info$avg_per_year) + x_buffer
#     this_nudge_x <- max(this_freq_info$avg_per_year) / 60 # 3.5 turns to 0.05
# 
#     # The lines for the plot
#     this_lines <- this_freq_info %>%
#         mutate(line_start = 0) %>%
#         pivot_longer(cols = c(line_start, avg_per_year), names_to = "line_position", values_to = "value")
# 
# 
#     p <- ggplot(this_freq_info, aes(every_x_years, hymn_num, ...)) +
#         geom_point() +
#         # geom_text(aes(label = label), nudge_x = this_nudge_x, hjust = 0, family = "Avenir", size = 3) +
#         # geom_line(data = this_lines, aes(x = value, group = hymn_num)) +
#         # # scale_x_continuous(limits = c(0, max_x), breaks = seq(0, 5, breaks),
#         # #                    expand = expansion(add = c(0, 0), mult = c(0,0))) +
#         scale_x_continuous(trans = c("log10", "reverse")) +
# 
#         # labs(x = "number of times sung",
#         #      y = NULL,
#         #      title = "Average number of times hymns are sung per year per ward",
#         #      subtitle = subtitle) +
#         theme_minimal(base_size = base_size, base_family = "Avenir") +
#         theme(axis.ticks.y = element_blank(),
#               axis.text.y = element_blank(),
#               axis.line.y = element_line(color = "gray80"))
# 
#     if (export) {
#         export_for_latex(..., plot = p)
#     }
# 
#     if (return == "plot") {
#         return(p)
#     }
#     if (return == "table") {
#         return(this_freq_info)
#     }
#     # if (return == "both") {
#     #     return(list(this_freq_info, p))
#     # }
# }

# freqs %>%
#     filter(hymn_num %in% :1) %>%
#     cleveland_plot_years(return = "plot")
```

```{r, eval = FALSE}
# temp <- freqs %>%
#     filter(hymn_num %in% 1:20) %>%
#     count(name_num) %>%
#     mutate(avg_per_year = n / get_n_distinct_meetings() * 48,
#            every_x_weeks = 48 / avg_per_year,
#            every_x_months = every_x_weeks / 48 * 12,
#            every_x_years  = 1 / avg_per_year) %>%
#     arrange(-avg_per_year) %>%
#     select(-n) %>%
#     arrange(-every_x_years) %>%
#     mutate(name_num = fct_inorder(name_num)) %>%
#     print()
#     
# ggplot(temp, aes(log10(every_x_years), name_num)) + 
#     geom_point() + 
#     scale_x_continuous(trans = c("reverse"), 
#                        breaks = log10(c(1, 3, 10, 30)),
#                        labels = c(1, 3, 10, 30),
#                        name = "years")
# 
# # This is supposed to work, but it doesn't: https://stackoverflow.com/questions/11053899/how-to-get-a-reversed-log10-scale-in-ggplot2/72506926#72506926
# ggplot(temp, aes(every_x_years, name_num)) + 
#     # geom_point() + 
#     geom_text(aes(label = round(every_x_years, 2))) + 
#     scale_x_continuous(trans = c("reciprocal"), breaks = c(1, 3, 10, 30))
# 
# ggplot(temp, aes(avg_per_year, name_num)) + 
#     geom_point()
```

```{r, eval = FALSE}
# p <- tibble(x = c(1, 3, 10, 30),
#             y = 1:4) %>%
#     ggplot(aes(x, y, label = x)) + 
#     geom_text()
# p
# 
# p + scale_x_continuous(breaks = c(1, 10, 30))
# p + scale_x_continuous(trans = "log10", breaks = c(1, 10, 30))
# p + scale_x_continuous(trans = "reciprocal", breaks = c(1, 10, 30))
```

### A sample

A sample, for the methods section

```{r}
# freqs %>%
#     filter(hymn_num == 2)
# freqs %>%
#     filter(hymn_num < 20) %>%
#     cleveland_plot(title = "", return = "table")
# freqs %>%
#     filter(hymn_num < 20) %>%
#     cleveland_plot(return = "both")
# 
# freqs %>%
#     filter(hymn_num <= 20,
#            !is.na(hymn_name)) %>%
#     cleveland_plot(return = "both", subtitle = "Hymns 1–20", 
#                    export = TRUE, name = "first_20", height = 3.5, width = 6)
# 
# freqs %>%
#     cleveland_plot(filter_n = 20, max_n = 30, inverse_x = FALSE)
```

## The "Davies Method"

This function takes a date range and finds which hymns are most common in that range, disregarding common hymns anyway. The `.range` argument is something like `month == 2 & day %in% 7:14`. The `.compare` argument is optional and is the same format as `.range`. If it's not there, it'll just look at the logical opposite of `.range`. There is a `.bonus` argument, but I'm not sure what it does.

The function prints two things. First, it'll show the hymns most common in `.range`. Then it'll show the hymns that stand out, according to the Davies method.

```{r}
davies_method <- function(.range, .compare, .bonus = 0.5, .df = freqs) {
    within_range <- .df %>%
        filter({{.range}}) %>%
        count(hymn_name, hymn_num, sort = TRUE) %>%
        mutate(within_range = n/sum(n) * 100) %>%
        arrange(-within_range) %>%
        filter(n > max(n)/4) %>%
        select(-n)
    
    if (missing(.compare)) {
        compare_fn <- function(df) { filter(df, !{{.range}}) }
    } else {
        compare_fn <- function(df) { filter(df, {{.compare}}) }
    }
    
    not_within_range <- .df %>%
        compare_fn() %>%
        count(hymn_name, hymn_num, sort = TRUE) %>%
        mutate(not_within_range = n/sum(n) * 100) %>%
        arrange(-not_within_range) %>%
        filter(n > max(n)/4) %>%
        select(-n)

    valentines <- left_join(within_range, not_within_range, by = c("hymn_name", "hymn_num")) %>%
        mutate(not_within_range = replace_na(not_within_range, .bonus)) %>%
        mutate(prop = within_range / not_within_range) %>%
        arrange(-prop) %>%
        print()


}
# davies_method(month == 2 & day %in% 7:14, month == 2 & day %in% 15:22)
```

## Look up one hymn

Just look up the stats for one hymn for my own curiosity.

```{r}
single_hymn_lookup <- function(.hymn_num, show_context = FALSE) {
    
    if (show_context == TRUE) {
        this_row_num <- freqs %>% 
            cleveland_plot(return = "table") %>%
            rowid_to_column("id") %>%
            filter(hymn_num %in% .hymn_num) %>%
            pull(id)
        freqs %>% 
            cleveland_plot(return = "table") %>%
            rowid_to_column("id") %>%
            filter(id >= this_row_num-9,
                   id <= this_row_num+9) %>%
            View()
    } else {
        freqs %>%
            cleveland_plot(return = "table") %>%
            filter(hymn_num %in% .hymn_num) %>%
            print()
    }
    
    freqs %>%
        filter(hymn_num %in% .hymn_num) %>%
        count(week) %>%
        ggplot(aes(week, n)) + 
        geom_point() + 
        geom_path() + 
        theme_bw()
    
    freqs %>%
        filter(hymn_num %in% .hymn_num,
               !is.na(type)) %>%
        count(type) %>%
        mutate(prop = n/sum(n)) %>%
        mutate(type = factor(type, levels = c("Opening", "Sacrament", "Intermediate", "Closing"))) %>%
        print() %>%
        ggplot(aes(type, n)) +
        geom_col() +
        theme_minimal()
}
# single_hymn_lookup(2)
# single_hymn_lookup(193)
# single_hymn_lookup(201)
# single_hymn_lookup(255)
# single_hymn_lookup(34, show_context = TRUE)
# single_hymn_lookup(33, show_context = TRUE)
```

## Other Functions

```{r}
get_hymn_name <- function(x) {
    freqs %>%
        select(hymn_name, hymn_num) %>%
        distinct() %>%
        filter(hymn_num == x) %>%
        pull(hymn_name)
}
# get_hymn_name(308)

search_titles <- function(x) {
     freqs %>%
        select(hymn_name, hymn_num) %>%
        distinct() %>%
        filter(str_detect(tolower(hymn_name), tolower(x))) %>%
        arrange(hymn_num)
}
# search_titles("Love")
# search_titles("Green")
# search_titles("fathers")
```

## Preloaded colors

```{r}
ptol_red <- "#EE6677"
ptol_green <- "#228833"
ptol_blue <- "#4477AA"
ptol_grey <- "#777777"
```


## Frequencies for note data


```{r}
freq_for_any <- function(.hymns) {
    if ("tbl" %in% class(.hymns)) {
        .hymns <- unique(.hymns$hymn_num)
    }
    
    just_these_hymns <- freqs %>%
        filter(hymn_num %in% .hymns)
    
    count_of_just_these <- nrow(just_these_hymns)
    print(paste("These hymns were sung a total of", count_of_just_these, "times in this sample."))
    print(paste0("That's ", round(count_of_just_these/nrow(freqs), 5)*100, "%"))
    
    prop_of_meetings <- count_of_just_these/get_n_distinct_meetings()
    years <- 1/(prop_of_meetings*48)
    print(paste("That means one of them is sung, on average, once every", round(years, 3), "years."))
    print(paste("   Or once every", round(years * 12, 3), "months."))
    print(paste("   Or once every", round(years * 48, 3), "weeks"))
}
# freq_for_any(c(1, 37, 77, 118, 120, 317))
# 
# freqs %>%
#     filter(hymn_num %in% c(1, 37, 77, 118, 120, 317)) %>%
#     freq_for_any()
```

## High and low note functions

### Highest note functions

A histogram of highest notes. I've added some extra arguments to make it a bit more flexible.

```{r}
get_highest_notes <- function(remove_unusual = FALSE, remove_soprano_alto_unison = FALSE){
    df <- notes %>%
        filter(!is.na(note)) %>%
        mutate(in_unison = !(sop_alto_unis_len <= 3 | is.na(sop_alto_unis_len)))
    
    if (remove_unusual) {
        df <- df %>% filter(!unusual)
    }
    
    no_unisons_df <- df %>%
        filter(!in_unison) %>%
        group_by(voice, name_num) %>%
        filter(midi == max(midi, na.rm = TRUE)) %>%
        distinct(name_num, hymn_num, midi, note_label)
    
    all_notes_df <- df %>%
        group_by(voice, name_num) %>%
        filter(midi == max(midi, na.rm = TRUE)) %>%
        distinct(name_num, hymn_num, midi, note_label)
    
    bind_rows("no_unisons" = no_unisons_df,
              "all_notes" = all_notes_df,
              .id = "unisons_removed") %>%
        ungroup() %>%
        mutate(unisons_removed = unisons_removed == "no_unisons") %>%
        arrange(hymn_num, voice, unisons_removed) %>%
        
        # Find the ones that are different
        group_by(name_num, voice) %>%
        mutate(n_distinct = length(unique(note_label))) %>%
        ungroup() %>%
        # Mark `unisons_removed` as NA if there is no difference
        mutate(unisons_removed = if_else(n_distinct == 1, NA, unisons_removed)) %>%
        distinct() %>%
        return()
    
}
# get_highest_notes() %>%
#     filter(hymn_num == 37)
# get_highest_notes(remove_soprano_alto_unison = TRUE)
```

Test to make sure things work

```{r, eval = FALSE}
get_highest_notes(remove_soprano_alto_unison = FALSE) %>%
    ggplot(aes(midi)) +
    geom_bar() +
    facet_wrap(~voice, ncol = 1, scales = "free_y") +
    scale_x_continuous(breaks = note_name_midi_lookup$midi,
                       labels = note_name_midi_lookup$note_label) +
    theme_bw()
```

### Lowest note functions

```{r}
get_lowest_notes <- function(remove_unusual = FALSE, remove_soprano_alto_unison = FALSE){
    df <- notes %>%
        filter(!is.na(note)) %>%
        mutate(in_unison = !(sop_alto_unis_len <= 3 | is.na(sop_alto_unis_len)))
    
    if (remove_unusual) {
        df <- df %>% filter(!unusual)
    }
    
    no_unisons_df <- df %>%
        filter(!in_unison) %>%
        group_by(voice, name_num) %>%
        filter(midi == min(midi, na.rm = TRUE)) %>%
        distinct(name_num, hymn_num, midi, note_label)
    
    all_notes_df <- df %>%
        group_by(voice, name_num) %>%
        filter(midi == min(midi, na.rm = TRUE)) %>%
        distinct(name_num, hymn_num, midi, note_label)
    
    bind_rows("no_unisons" = no_unisons_df,
              "all_notes" = all_notes_df,
              .id = "unisons_removed") %>%
        ungroup() %>%
        mutate(unisons_removed = unisons_removed == "no_unisons") %>%
        arrange(hymn_num, voice, unisons_removed) %>%
        
        # Find the ones that are different
        group_by(name_num, voice) %>%
        mutate(n_distinct = length(unique(note_label))) %>%
        ungroup() %>%
        # Mark `unisons_removed` as NA if there is no difference
        mutate(unisons_removed = if_else(n_distinct == 1, NA, unisons_removed)) %>%
        distinct() %>%
        return()
    
}
get_lowest_notes() %>%
    filter(hymn_num == 37)
```

Functions to make sure it works.

```{r, eval = FALSE}
get_lowest_notes() %>%
    ggplot(aes(midi, fill = unisons_removed)) + 
    geom_bar() + 
    facet_wrap(~voice, ncol = 1, scales = "free_y") + 
    scale_x_continuous(breaks = note_name_midi_lookup$midi, 
                       labels = note_name_midi_lookup$note_label) + 
    theme_bw()
```

### Both functions

```{r}
highest_lowest_note_stats <- function(.voice, .note, .extreme = "high", 
                                      .return = c("table", "summary", "plot"), 
                                      .cleveland_return = "plot", ...) {
    
    if (.extreme == "high") { 
        this_df <- get_highest_notes(...)
    } else { 
        this_df <- get_highest_notes(...)
    }
    
    list_of_hymns <- this_df %>%
        filter(voice == .voice) %>%
        arrange(voice, -midi) %>%
        filter(note_label %in% .note)
    
    freqs_data <- freqs %>%
        filter(name_num %in% list_of_hymns$name_num)
    
    if (length(.return) == 1 && "table" == .return) {
        return(list_of_hymns)
    } else if ("table" %in% .return) {
        print(list_of_hymns)
    }

    if ("summary" %in% .return) {
        n_hymns <- nrow(list_of_hymns)
        print(paste0("In total, there are ", n_hymns, " that are included here (",
                     round(n_hymns/341, 5)*100, "% of the hymnal)."))

        n_hymn_unisons_removed <- list_of_hymns %>% filter(unisons_removed | is.na(unisons_removed)) %>% nrow()
        print(paste0("   But if you ignore the unison passages, there are ", n_hymn_unisons_removed, " hymns (",
                     round(n_hymn_unisons_removed/341, 5)*100, "% of the hymnal)."))

        freq_for_any(freqs_data)
    }
    
    if (length(.return) == 1 && "plot" == .return) {
        return(cleveland_plot(freqs_data, return = .cleveland_return, ...) )
    } else if ("plot" %in% .return) {
        cleveland_plot(freqs_data, return = .cleveland_return, ...) 
    }
}
# highest_lowest_note_stats("soprano", "F5", "high", .return = "plot", .cleveland_return = "both")
# 
# freqs %>%
#     filter(hymn_num == 37)
```